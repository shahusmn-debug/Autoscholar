# src/tools.py
"""
Python Sandbox - Safe Code Execution for Chart Generation

This module provides a sandboxed environment for executing
Python code generated by the Analyst agent. Key features:
- Automatic matplotlib backend configuration (Agg for headless)
- Path injection for output files
- Restricted imports for security
- Detailed error capture for self-correction
"""

import subprocess
import tempfile
import os
import sys
from pathlib import Path
from typing import Tuple, Optional
from dataclasses import dataclass


@dataclass
class ExecutionResult:
    """Result of executing Python code in the sandbox."""
    success: bool
    output: str          # stdout from execution
    error: str           # stderr from execution
    output_files: list   # List of files created


# Allowed imports for chart generation
ALLOWED_IMPORTS = {
    "pandas", "numpy", "matplotlib", "matplotlib.pyplot",
    "seaborn", "scipy", "scipy.stats", "os", "pathlib", "json"
}

# Code prefix to ensure matplotlib headless operation
MATPLOTLIB_PREAMBLE = '''
import matplotlib
matplotlib.use('Agg')  # Headless backend - MUST be before pyplot import
import matplotlib.pyplot as plt
'''


def execute_python_code(
    code: str,
    output_dir: str,
    data_dir: str,
    timeout_seconds: int = 60
) -> ExecutionResult:
    """
    Execute Python code in a sandboxed subprocess.
    
    The code is modified to:
    1. Use matplotlib's Agg backend (no GUI)
    2. Inject paths for data input and figure output
    
    Args:
        code: The Python code to execute
        output_dir: Directory where figures should be saved
        data_dir: Directory containing input data files
        timeout_seconds: Maximum execution time
        
    Returns:
        ExecutionResult with success status, output, errors, and created files
    """
    # Create output directory if needed
    output_path = Path(output_dir)
    output_path.mkdir(parents=True, exist_ok=True)
    
    # Inject paths and matplotlib config
    path_injection = f'''
# Path injection by AutoScholar
DATA_DIR = r"{data_dir}"
OUTPUT_DIR = r"{output_dir}"
'''
    
    # Combine preamble, paths, and user code
    full_code = MATPLOTLIB_PREAMBLE + path_injection + "\n" + code
    
    # Track files before execution
    files_before = set(output_path.glob("*"))
    
    # Write to temporary file
    with tempfile.NamedTemporaryFile(
        mode='w',
        suffix='.py',
        delete=False,
        encoding='utf-8'
    ) as f:
        f.write(full_code)
        temp_script = f.name
    
    try:
        # Execute in subprocess
        result = subprocess.run(
            [sys.executable, temp_script],
            capture_output=True,
            text=True,
            timeout=timeout_seconds,
            cwd=data_dir,  # Run from data directory
            env={**os.environ, "MPLBACKEND": "Agg"}
        )
        
        # Check for new files
        files_after = set(output_path.glob("*"))
        new_files = list(files_after - files_before)
        
        success = result.returncode == 0
        
        return ExecutionResult(
            success=success,
            output=result.stdout,
            error=result.stderr,
            output_files=[str(f) for f in new_files]
        )
        
    except subprocess.TimeoutExpired:
        return ExecutionResult(
            success=False,
            output="",
            error=f"Execution timed out after {timeout_seconds} seconds",
            output_files=[]
        )
    except Exception as e:
        return ExecutionResult(
            success=False,
            output="",
            error=str(e),
            output_files=[]
        )
    finally:
        # Clean up temp file
        try:
            os.unlink(temp_script)
        except:
            pass


def save_code_artifact(
    code: str,
    figure_id: str,
    attempt: int,
    tools_dir: str
) -> str:
    """
    Save generated code to the tools directory for debugging.
    
    Args:
        code: The Python code
        figure_id: Identifier for the figure (e.g., "fig_1")
        attempt: Which attempt number (for retries)
        tools_dir: Path to the tools directory
        
    Returns:
        Path to the saved file
    """
    tools_path = Path(tools_dir)
    tools_path.mkdir(parents=True, exist_ok=True)
    
    filename = f"{figure_id}_attempt_{attempt}.py"
    filepath = tools_path / filename
    
    with open(filepath, 'w', encoding='utf-8') as f:
        f.write(code)
    
    return str(filepath)


def save_execution_output(
    result: ExecutionResult,
    figure_id: str,
    attempt: int,
    tools_dir: str
) -> str:
    """
    Save execution output/errors for debugging.
    
    Args:
        result: The ExecutionResult from code execution
        figure_id: Identifier for the figure
        attempt: Which attempt number
        tools_dir: Path to the tools directory
        
    Returns:
        Path to the saved output file
    """
    tools_path = Path(tools_dir)
    tools_path.mkdir(parents=True, exist_ok=True)
    
    filename = f"{figure_id}_attempt_{attempt}.stdout.txt"
    filepath = tools_path / filename
    
    content = f"SUCCESS: {result.success}\n\n"
    content += "=== STDOUT ===\n"
    content += result.output or "(empty)"
    content += "\n\n=== STDERR ===\n"
    content += result.error or "(empty)"
    content += "\n\n=== OUTPUT FILES ===\n"
    content += "\n".join(result.output_files) or "(none)"
    
    with open(filepath, 'w', encoding='utf-8') as f:
        f.write(content)
    
    return str(filepath)
